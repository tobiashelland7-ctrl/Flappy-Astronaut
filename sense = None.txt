
# shishkebab.py
# Flappy-style game in Pygame Zero, optional player sprite.

import random
import pygame
from pygame import Rect
from pgzero.keyboard import keys
from pgzero.actor import Actor  # used to load the image

# ------------------------------------------------------------
# Window size
WIDTH = 400
HEIGHT = 600

# Game variables
gap = 160                 # vertical gap between pipes
pipe_speed = 2.5
gravity = 0.35
jump_strength = -6.5
score = 0
game_over = False
velocity = 0.0

# Horizontal distance between successive pipes
PIPE_SPACING = 280

# Player baseline (circle)
player_x = 75
player_y = HEIGHT // 2
player_radius = 18  # ball radius; sprite will be scaled to diameter = 2 * radius

# Sprite toggle
USE_SPRITE = True         # set False to revert to circle
PLAYER_IMAGE = 'player'   # expects images/player.png
player_sprite = None      # Actor (for loading & position)
player_surf = None        # scaled pygame.Surface we actually blit

# Pipes: list of dicts with 'top' and 'bottom' Rects
pipes = []


def _create_pipe_pair(x_start: int):
    """Create a top/bottom pipe Rect pair starting at x_start."""
    top_height = random.randint(80, HEIGHT - gap - 120)
    return {
        'top': Rect((x_start, 0), (70, top_height)),
        'bottom': Rect((x_start, top_height + gap), (70, HEIGHT - (top_height + gap)))
    }


def _reset_pipes():
    """Initialize three pipes spaced to the right off-screen."""
    global pipes
    pipes = []
    for i in range(3):
        pipes.append(_create_pipe_pair(WIDTH + i * PIPE_SPACING))


def _build_scaled_sprite():
    """
    Load the sprite via Actor, scale to ball diameter, and produce
    a surface we can blit directly. Keeps transparency intact.
    """
    global player_sprite, player_surf
    player_sprite = Actor(PLAYER_IMAGE)
    diameter = max(1, int(player_radius * 2))
    # Scale the actor's surface to our target diameter and ensure alpha is preserved
    src = player_sprite._surf
    scaled = pygame.transform.smoothscale(src, (diameter, diameter)).convert_alpha()
    player_surf = scaled
    # Keep the actor's position so we can reuse (centered blit)
    player_sprite.pos = (player_x, player_y)


def reset_game():
    """Reset all game state to start a new round."""
    global velocity, score, game_over, pipes, player_y, player_sprite, player_surf
    velocity = 0.0
    score = 0
    game_over = False
    player_y = HEIGHT // 2
    _reset_pipes()

    if USE_SPRITE:
        _build_scaled_sprite()
    else:
        player_sprite = None
        player_surf = None


def draw():
    """Pygame Zero draw() hook."""
    screen.clear()

    # --- Background: starry sky + grass ---
    screen.draw.filled_rect(Rect((0, 0), (WIDTH, HEIGHT - 80)), (11, 13, 26))  # sky
    for x in range(10, WIDTH, 40):
        for y in range(10, HEIGHT - 110, 60):
            screen.draw.filled_circle((x + (y % 13), y), 1, "white")            # stars
    screen.draw.filled_rect(Rect((0, HEIGHT - 80), (WIDTH, 80)), (34, 139, 34))  # grass

    # --- Pipes ---
    for pipe in pipes:
        screen.draw.filled_rect(pipe['top'], (0, 180, 0))
        screen.draw.filled_rect(pipe['bottom'], (0, 180, 0))

    # --- Player (image or circle) ---
    if USE_SPRITE and player_surf is not None and player_sprite is not None:
        # Blit the scaled surface centered at (player_x, player_y)
        rect = player_surf.get_rect(center=(player_x, int(player_y)))
        screen.surface.blit(player_surf, rect)
    else:
        screen.draw.filled_circle((player_x, int(player_y)), player_radius, "white")
        screen.draw.line(
            (player_x - 10, int(player_y) - 3),
            (player_x + 10, int(player_y) - 3),
            (180, 220, 255)
        )

    # --- HUD ---
    screen.draw.text(f"Score: {score}", (10, 10), fontsize=36, color="yellow")

    if game_over:
        screen.draw.text("GAME OVER", center=(WIDTH // 2, HEIGHT // 2 - 20),
                         fontsize=56, color="red")
        screen.draw.text("Press SPACE / UP to restart",
                         center=(WIDTH // 2, HEIGHT // 2 + 30),
                         fontsize=28, color="white")


def update():
    """Pygame Zero update() hook â€” physics, pipes, collision."""
    global player_y, velocity, game_over, score, pipes, player_sprite

    if game_over:
        return

    # Gravity
    velocity += gravity
    player_y += velocity

    # Keep sprite center in sync with physics (if using)
    if USE_SPRITE and player_sprite is not None:
        player_sprite.pos = (player_x, player_y)  # pos is still our logical center

    # Move pipes left
    for pipe in pipes:
        pipe['top'].x -= pipe_speed
        pipe['bottom'].x -= pipe_speed

    # Recycle pipe + score when the first pipe leaves the screen
    if pipes and pipes[0]['top'].x < -70:
        pipes.pop(0)
        score += 1
        last_x = pipes[-1]['top'].x if pipes else WIDTH
        pipes.append(_create_pipe_pair(last_x + PIPE_SPACING))

    # Collision detection (circle-rect overlap approximation via bounding box)
    player_rect = Rect(
        (player_x - player_radius, int(player_y) - player_radius),
        (player_radius * 2, player_radius * 2)
    )
    for pipe in pipes:
        if player_rect.colliderect(pipe['top']) or player_rect.colliderect(pipe['bottom']):
            game_over = True
            break

    # Bounds check (top/bottom of screen)
    if player_y < 0 or player_y > HEIGHT:
        game_over = True


def on_key_down(key):
    """Handle jump and restart."""
    global velocity, game_over
    if key in (keys.SPACE, keys.UP):
        if game_over:
            reset_game()
        else:
            velocity = jump_strength


## Initialize everything (pipes + sprite + state) once at startup
reset_game()

# Entry point for plain Python if needed.
if __name__ == "__main__":
    import pgzrun

